# 技術スタック

## バックエンド([Python](https://www.python.org/))

[UV](https://docs.astral.sh/uv/)
* **概要:**
  + Pythonの依存関係管理・インストール・仮想環境作成を高速かつ一元的に行える次世代パッケージマネージャ。
  + pip, venv, pip-tools, pipenv, poetryなどの機能を統合し、極めて高速な処理とシンプルな操作性を実現。
  + [マニュアル](https://docs.astral.sh/uv/getting-started/installation/)に従ってインストールして下さい。
* **選定理由:**
  + 従来のpipやvenvに比べて依存解決・インストールが圧倒的に高速。
  + シングルバイナリでセットアップが容易、CI/CDやチーム開発でも再現性が高い。
  + requirements.txtやpyproject.tomlなど、既存のエコシステムとも高い互換性。
* **デメリット・注意点:**
  + 新しいツールのため、まれにpipの全ての挙動を100%再現できない場合や、uv本体のバグに遭遇する可能性がある（運用リスク）。
  + ただし、`uv pip`コマンドを利用することで、従来のpipと同等の互換性・ワークフローを多くの場合で確保できる。

[FastAPI](https://fastapi.tiangolo.com/)
* **概要:**
  + Python製の高速なWeb APIフレームワーク。型ヒントを活用した自動ドキュメント生成や非同期処理に対応し、現代的なAPI開発に最適。
* **選定理由:**
  + PythonはAI/機械学習分野で最も広く使われており、豊富なライブラリ（PyTorch, TensorFlow, Transformers等）と高い拡張性を持つ。
  + FastAPIは非同期処理・型安全・自動ドキュメント生成（OpenAPI）など、現代的なWeb API開発に最適。
  + 開発効率が高く、AI推論APIやバッチ処理、Webhook受信など幅広い用途に対応可能。
* **デメリット・注意点:**
  + Pythonは高負荷なリアルタイム処理やマルチスレッド性能でNode.jsやGoに劣る場合がある（パフォーマンス面の制約）。
  + FastAPIの大規模運用ノウハウはDjango等に比べてやや少なめ（運用上のリスク）。
  + 型ヒントや非同期処理の理解が必要。
* **パフォーマンス最適化:**
  + 非同期処理は適材適所で活用する（CPU依存の重い処理には不向き）
  + Redis/Memcachedによるキャッシュ戦略を実装（レスポンスキャッシュ、計算結果キャッシュ）
  + 大量データ処理時はストリーミングレスポンスの活用
  + 長時間処理はバックグラウンドタスク（Celery/Arq/Huey等）に委譲

### 静的解析・テストツール（バックエンド/Python）

[ruff](https://docs.astral.sh/ruff/)
* **概要:**
  + Pythonコードの静的解析・フォーマット・リントを超高速で実行できる次世代ツール。
  + flake8, isort, black, pylintなどの機能を統合。
* **選定理由:**
  + 圧倒的な実行速度と高い互換性。
  + 設定がシンプルでCI/CDにも組み込みやすい。
  + Pythonコミュニティで急速にデファクト化。
* **デメリット・注意点:**
  + 一部の高度なカスタムルールや古いツールとの完全な互換性は未対応の場合がある。

[pytest](https://docs.pytest.org/)
* **概要:**
  + Pythonの標準的なテストフレームワーク。シンプルな記法で単体テスト・統合テスト・モック等に対応。
* **選定理由:**
  + 豊富なプラグインとドキュメント、コミュニティサポート。
  + テストの自動検出や柔軟なフィクスチャ機能。
* **デメリット・注意点:**
  + 大規模テストや複雑な依存関係では設定が煩雑になる場合がある。

## フロントエンド

[pnpm](https://pnpm.io/)
* **概要:**
  + Node.js/JavaScript/TypeScriptプロジェクト向けの次世代パッケージマネージャー。高速・省スペース・高い一貫性が特徴。
* **選定理由:**
  + npm/yarnに比べてインストール速度が速く、ディスク使用量も大幅に削減。
  + モノレポやCI/CDとの親和性が高く、Next.js公式でも推奨されている。
  + lockfileの一貫性が高く、チーム開発でのトラブルが少ない。
* **デメリット・注意点:**
  + 一部の古いnpm/yarn向けツールやスクリプトとの互換性に注意が必要。

[Next.js](https://nextjs.org/) (TypeScript) + [shadcn/ui](https://ui.shadcn.com/)
* **概要:**
  + Reactベースのフレームワークで、静的サイト生成（SSG）、サーバーサイドレンダリング（SSR）、クライアントサイドレンダリング（CSR）に柔軟に対応。shadcn/uiは高品質なUIコンポーネント集。
* **選定理由:**
  + Next.jsはSSR/SSG/CSRの柔軟な切り替えが可能で、SEOやパフォーマンスに優れる。
  + Vercelとの親和性が高く、デプロイやCDN、サーバーレス運用が容易。
  + TypeScriptによる型安全な開発と、shadcn/uiによる高品質なUIを短期間で構築できる。
* **デメリット・注意点:**
  + SSRやISRの仕組みを誤るとパフォーマンスやSEOで逆効果になる場合がある（パフォーマンスリスク）。
  + shadcn/uiは比較的新しいため、将来的な仕様変更やサポート状況に注意（運用リスク）。

[Vite](https://vitejs.dev/)
* **概要:**
  + 次世代のフロントエンドビルドツール。超高速な開発サーバー起動とビルド、モダンなエコシステム対応。
* **選定理由:**
  + Next.js単体では不要だが、shadcn/uiやStorybook、独自のUI開発・ドキュメント用途でViteを併用するケースが増加。
  + 開発体験が非常に高速で、設定もシンプル。
* **デメリット・注意点:**
  + Next.js本体のビルドには不要。プロジェクト構成によっては導入不要な場合もある。

### 静的解析・テストツール（フロントエンド/Next.js, TypeScript）

[ESLint](https://eslint.org/)
* **概要:**
  + JavaScript/TypeScriptの静的解析・リントツール。コード品質・一貫性を自動チェック。
* **選定理由:**
  + Next.jsやTypeScriptとの親和性が高く、公式テンプレートでも標準採用。
  + 豊富なプラグインとカスタマイズ性。
* **デメリット・注意点:**
  + 設定が複雑化しやすく、プロジェクトごとに最適化が必要。

[Prettier](https://prettier.io/)
* **概要:**
  + コードフォーマッタ。自動で一貫したスタイルに整形。
* **選定理由:**
  + ESLintと併用することで、可読性と保守性が向上。
  + チーム開発でのスタイル統一に有効。
* **デメリット・注意点:**
  + 一部の細かいスタイル調整は難しい場合がある。

[Jest](https://jestjs.io/)
* **概要:**
  + JavaScript/TypeScriptのテストフレームワーク。ユニットテスト・スナップショットテスト・モック等に対応。
* **選定理由:**
  + Next.js公式推奨。高速な実行と豊富なエコシステム。
  + CI/CDとの連携が容易。
* **デメリット・注意点:**
  + 大規模プロジェクトでは設定やパフォーマンスチューニングが必要な場合がある。

[Testing Library](https://testing-library.com/)
* **概要:**
  + React/Next.jsコンポーネントのユーザー視点でのテストを実現するツール群。
* **選定理由:**
  + 実際のユーザー操作に近い形でテストが書ける。
  + Jestと組み合わせて利用することで、UIの品質保証が容易。
* **デメリット・注意点:**
  + 複雑なUIや非同期処理のテストには工夫が必要な場合がある。

## AI連携

[OpenAI API](https://platform.openai.com/)
* **概要:**
  + GPT-4などの大規模言語モデルや画像生成モデルをAPI経由で利用できるクラウドAIサービス。
* **選定理由:**
  + 最新のLLM（GPT-4等）や画像生成モデルを手軽に利用可能。
* **デメリット・注意点:**
  + OpenAI APIは従量課金制でコストが読みにくく、利用量が増えると運用コストが急増するリスク。
  + APIの利用制限やレートリミットにより、同時大量リクエスト時のパフォーマンス低下やサービス停止リスク。

[LangChain](https://python.langchain.com/)
* **概要:**
  + LLM（大規模言語モデル）を活用したAIエージェントやチャットボット、RAG（検索拡張生成）などの高度なAIアプリ開発を支援するフレームワーク。
* **選定理由:**
  + AIエージェントやチャットボット、RAG（検索拡張生成）などの高度なAIアプリ開発を効率化。
  + 独自モデルや外部AIサービスとの連携も柔軟に実現できる。
* **デメリット・注意点:**
  + LangChainはバージョンアップが早く、仕様変更に追従する必要がある（運用リスク）。
  + 機密データの外部送信には十分な配慮が必要（セキュリティリスク）。

## データベース/BaaS

[Supabase](https://supabase.com/)
* **概要:**
  + オープンソースのBaaS（Backend as a Service）。PostgreSQLベースのDB、認証、ストレージ、リアルタイムAPIなどを統合的に提供。
* **選定理由:**
  + PostgreSQLベースのDB・認証・ストレージ・リアルタイムAPIを一括管理。
  + サーバーレスでスケーラブルなバックエンドを迅速に構築でき、管理画面やドキュメントも充実。
  + フロントエンドやAIサービスとの連携も容易。
* **デメリット・注意点:**
  + 無料枠にはリソース制限があり、商用利用や大規模運用時は有料プランが必要（コストリスク）。
  + 一部機能はまだβ版や開発中のものがあり、安定性や将来の仕様変更に注意（運用リスク）。
  + ベンダーロックインのリスクがある（拡張性・移行性の制約）。

## インフラ

[Vercel](https://vercel.com/)
* **概要:**
  + Next.js公式のクラウドホスティングサービス。CDN、サーバーレス、SSL、カスタムドメインなど本番運用に必要な機能をワンクリックで提供。
* **選定理由:**
  + Next.jsとの親和性が高く、デプロイ・CDN・サーバーレス運用がワンクリックで可能。
  + 自動スケーリングやSSL、カスタムドメイン対応など本番運用に必要な機能が揃っている。
  + 開発から本番までの運用負荷を大幅に軽減。
* **デメリット・注意点:**
  + 無料枠には帯域やビルド回数などの制限があり、商用・大規模運用時はコスト増加リスク。
  + サーバーレス環境特有のコールドスタートやタイムアウト制限があり、リアルタイム性や長時間処理には不向き（パフォーマンスリスク）。
  + カスタムなインフラ要件や特殊な構成には不向きな場合がある（拡張性の制約）。
* **代替選択肢:**
  + **AWS Amplify/App Runner:** Next.jsのSSR/ISRにも対応、より柔軟なカスタマイズが必要な場合
  + **Google Cloud Run:** コンテナベースで移植性高く、コスト効率を重視する場合
  + **Azure Static Web Apps:** Microsoft製品との連携が必要な企業向け
  + **Cloudflare Pages:** 大規模CDN活用が必要な場合

## CI/CD・開発効率化

> **注意:**
> DependabotやRenovateによる依存関係の自動アップデートを安全に運用するためには、必ず自動テスト（CI）を導入し、アップデートPRごとにテストが通ることを確認してからマージ・デプロイすることが必須です。

[Trivy](https://aquasecurity.github.io/trivy/)
* **概要:**
  + OSSの脆弱性スキャナ。Dockerイメージ、アプリ依存パッケージ、IaC（Terraform, Kubernetes等）の脆弱性や設定ミスを一括検出。
* **選定理由:**
  + CI/CDやローカル開発で簡単にセキュリティチェックを自動化できる。
  + 多言語・多層の脆弱性を一括で検査可能。
  + シンプルなコマンドと高速なスキャンで、開発フローに組み込みやすい。
  + 豊富なドキュメントと活発なコミュニティサポート。
* **デメリット・注意点:**
  + 新しい脆弱性DBへの反映にタイムラグがある場合がある。
  + 誤検知や過検知が発生することがあるため、運用時はレビューも必要。

[GitHub Actions](https://github.com/features/actions)
* **概要:**
  + GitHubリポジトリと連携し、テスト・ビルド・デプロイなどのCI/CDパイプラインを自動化できるワークフローエンジン。
* **選定理由:**
  + 自動テスト・自動デプロイを実現し、品質と開発効率を向上。
* **デメリット・注意点:**
  + GitHub Actionsの無料枠には実行時間やストレージ制限があり、大規模運用時はコスト増加リスク。

[Docker](https://www.docker.com/)
* **概要:**
  + アプリケーションの実行環境をコンテナ化し、ローカル・本番で同一の環境を再現できるプラットフォーム。
* **選定理由:**
  + ローカル/本番の環境差異を解消し、再現性の高い開発・運用が可能。
* **デメリット・注意点:**
  + Dockerのビルドや運用にはセキュリティやリソース消費の管理が必要（運用リスク・パフォーマンスリスク）。
  + シークレット管理やイメージの脆弱性対策が必須（セキュリティリスク）。

[Dependabot](https://github.com/dependabot)
* **概要:**
  + GitHub公式の依存関係アップデート自動化ツール。PRで安全なアップデートを提案し、セキュリティアラートにも対応。
* **選定理由:**
  + Python（pip/poetry/uv）、Node.js（npm/yarn/pnpm）、Docker、GitHub Actionsなど幅広く対応。
  + セキュリティ脆弱性の自動検知・修正提案。
  + GitHubと統合されており、CI/CDと連携しやすい。
* **デメリット・注意点:**
  + プライベートリポジトリや大規模プロジェクトではPR数が多くなりがち。

[Renovate](https://www.mend.io/renovate/)
* **概要:**
  + 依存関係の自動アップデートBot。多様なVCSやパッケージエコシステムに対応し、柔軟な設定が可能。
* **選定理由:**
  + Dependabotのデメリット（PR数の多さ、細かい制御の難しさ、GitHub専用など）を補完・解決するため。
  + PRの粒度やスケジュール、ルールを細かく制御できる。
* **デメリット・注意点:**
  + 設定がやや複雑で、最適化にはプロジェクトごとの調整が必要。

## ワークフロー自動化

[n8n](https://n8n.io/)
* **概要:**
  + ノーコード/ローコードでさまざまなサービスやAPIを連携し、業務プロセスやバッチ処理を自動化できるワークフローオートメーションツール。
* **選定理由:**
  + 外部サービス連携やバッチ処理をノーコード/ローコードで自動化でき、業務効率化に貢献。
  + 多数のサービスと連携可能で、複雑なワークフローもGUIで直感的に構築可能。
* **デメリット・注意点:**
  + セルフホストの場合は運用・保守の負担やセキュリティ管理が発生（運用リスク）。
  + 複雑なワークフローや大量データ処理時のパフォーマンス低下リスク。
  + クラウド版は無料枠に制限があり、商用利用や大規模運用時は有料プランが必要（コストリスク）。

## ドキュメント管理

[Docusaurus](https://docusaurus.io/)
* **概要:**
  + Reactベースの静的サイトジェネレータ。Markdownで技術ドキュメントや公式サイトをモダンなUIで構築可能。
* **選定理由:**
  + 多言語対応やカスタムUI、ブログ機能など拡張性が高い。
  + OSSプロジェクトやプロダクトサイトにも最適。
* **デメリット・注意点:**
  + Node.js環境が必要。
  + 高度なカスタマイズにはReactの知識が求められる。

## モニタリング・可観測性

[Sentry（OSS/self-hosted）](https://github.com/getsentry/sentry)
* **概要:**
  + アプリケーションのエラー監視・例外トラッキングに特化したOSS。スタックトレースやリクエスト情報、ユーザー情報など詳細なエラーコンテキストを自動収集。
  + パフォーマンスモニタリング（APM）機能も一部対応。
* **選定理由:**
  + FastAPIやNext.jsなど主要フレームワークと公式SDKで簡単に連携可能。
  + バグ・例外の早期検知と詳細な原因分析ができ、ユーザー影響のある障害を即座に把握できる。
  + セルフホストでコストを抑えつつ、機密データも自社管理可能。
* **デメリット・注意点:**
  + 無料枠では機能制限やイベント数制限があり、本格運用には有料プランまたはセルフホスト運用が必要。
  + 機密データの自動収集リスクがあるため、フィルタリング設定が重要。
  + サーバー運用・ストレージ管理の負荷が発生する。

[Prometheus](https://prometheus.io/) + [Grafana](https://grafana.com/)
* **概要:**
  + OSSの時系列メトリクス監視・可視化基盤。Prometheusがメトリクス収集・保存、Grafanaがダッシュボードでの可視化を担当。
  + システム全体のパフォーマンスやリソース消費、APIレスポンスタイム、DB負荷などを俯瞰的に監視可能。
* **選定理由:**
  + Docker/Kubernetes環境やSupabase、FastAPI/Next.jsのメトリクス監視に親和性が高い。
  + カスタムメトリクスも柔軟に追加でき、インフラ・アプリの健康状態やボトルネックを可視化できる。
  + アラート設定で障害の予兆も検知可能。
  + OSSなのでコストゼロで大規模運用も可能。
* **デメリット・注意点:**
  + 初期セットアップやダッシュボード設計に一定の知識が必要。
  + サーバー運用・ストレージ管理の負荷が発生する。
  + メトリクス粒度や保存期間によってはストレージコストが増加する場合がある。
